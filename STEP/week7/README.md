## Week７

### 宿題１
行列積のループ順序としては6種類の組合せがある。この6種類を実行速度が速いと思う方から順に並べてください。実際に実験してその予想が正しいかどうか確かめてください。<br>

＜予想＞<br>
連続的なメモリアクセスはキャッシュヒット率を上げ、プログラムの高速化につながる。そこで、最内ループに注目すると以下のようにグループ分けできる。<br>

グループa: 不連続アクセスがない。<br>
i-k-j: c[i][j]が連続、a[i][k]が不変、b[k][j]が連続<br>
k-i-j: c[i][j]が連続、a[i][k]が不変、b[k][j]が連続<br>

グループb: 離散アクセスが１箇所。<br>
j-i-k: c[i][j]が不変、a[i][k]が連続、b[k][j]が不連続<br>
i-j-k: c[i][j]が不変、a[i][k]が連続、b[k][j]が不連続<br>

グループc: 離散アクセスが２箇所。<br>
j-k-i: c[i][j]が不連続、a[i][k]が不連続、b[k][j]が不変<br>
k-j-i: c[i][j]が不連続、a[i][k]が不連続、b[k][j]が不変<br>

離散アクセスが多いほど、キャッシュミスが起こる確率が高くなり、キャッシュミスが起こるとメモリまでデータを取りに行く必要性が生じるので計算時間が大きくなる。<br>
よってかかる時間は<br>
グループa < グループb < グループc<br>
になると予想できる。（同じグループ内ではかかる時間がほぼ同じ）<br>


＜実験＞<br>
```
gcc matrix.c -o matrix
./matrix 1024
```
matrix.cの38,39,40行目を入れ替えてまた実験する。matrix.cを書き換えるたびに上の2行を実行し直す必要がある。<br>


＜結果＞<br>
N = 1024で調べた。＊時間は測るたびに1~2秒変わる。<br>
i-k-j: 4.214747 sec<br>
k-i-j: 4.359899 sec<br>
j-i-k: 29.514298 sec<br>
i-j-k: 29.950374 sec<br>
j-k-i: 35.115300 sec<br>
k-j-i: 36.164341 sec<br>
予想は正しいと言える。<br>


## 宿題２<br>
C言語で行列積を書くと、i-k-jループのほうがi-j-kループよりもずっと速かった。でも、実はPythonで書くと、ループ順序を入れ替えても速度差はほとんどない。その理由を考えてください。<br>


まず、pythonとC言語でどのくらい計算にかかる時間が違うのかを調べてみた。
```
gcc matrix.c -o matrix
./matrix 256
```
```
0.114014 sec
```
```
python matrix.py 256
```
```
28.298978 sec
```
N=256では、なんと200倍以上pythonの方が遅いことが分かった。<br>
これを踏まえて、pythonで速度差が変わらない理由はpythonがインタプリタ言語であるために処理が遅く、（メモリにデータを取りに行く時間）<<（字句解析、構文解析などにかかる時間）となるためにループの順番を入れ替えることによるスピード向上が目に現れないのではないかと考えた。<br>
Nが小さくなればループの順序による計測時間の差が現れるのではないかと思い、N=10で実験してみた。が、計算時間はループの順序に依存しなかった。そこで別の理由を考える。<br>

ループの順序を変えると計算時間が少なくなる理由はキャッシュヒット率が上がるからであった。キャッシュヒット率を上げるためには<br>
1. アクセスするメモリ領域を小さくする<br>
2. 連続的にメモリにアクセスする<br>

をすれば良い。ここで、1つ目に注目した。プログラムをコンパイルすると最適化をするために機械語が生成されるが、この文余分なメモリを使うことになる。逆に、機械語を生成しないpythonは必要最低限のメモリしか使わない。これによってキャッシュヒット率が上がると考えられる。以上より、使用するメモリが少なく、連続でない領域もキャッシュ/レジスタ上に存在する確率が高まるためにpythonでの計算時間はループの順序に依存しないのではないかと思われる。<br>