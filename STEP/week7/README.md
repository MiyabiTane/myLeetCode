## Week７

### 宿題１
行列積のループ順序としては6種類の組合せがある。この6種類を実行速度が速いと思う方から順に並べてください。実際に実験してその予想が正しいかどうか確かめてください。<br>

＜予想＞<br>
連続的なメモリアクセスはキャッシュヒット率を上げ、プログラムの高速化につながる。そこで、最内ループに注目すると以下のようにグループ分けできる。<br>

グループa: 不連続アクセスがない。<br>
i-k-j: c[i][j]が連続、a[i][k]が不変、b[k][j]が連続<br>
k-i-j: c[i][j]が連続、a[i][k]が不変、b[k][j]が連続<br>

グループb: 離散アクセスが１箇所。<br>
j-i-k: c[i][j]が不変、a[i][k]が連続、b[k][j]が不連続<br>
i-j-k: c[i][j]が不変、a[i][k]が連続、b[k][j]が不連続<br>

グループc: 離散アクセスが２箇所。<br>
j-k-i: c[i][j]が不連続、a[i][k]が不連続、b[k][j]が不変<br>
k-j-i: c[i][j]が不連続、a[i][k]が不連続、b[k][j]が不変<br>

離散アクセスが多いほど、キャッシュミスが起こる確率が高くなり、キャッシュミスが起こるとメモリまでデータを取りに行く必要性が生じるので計算時間が大きくなる。<br>
よってかかる時間は<br>
グループa < グループb < グループc<br>
になると予想できる。（同じグループ内ではかかる時間がほぼ同じ）<br>


＜実験＞<br>
```
gcc matrix.c -o matrix
./matrix 1024
```
matrix.cの38,39,40行目を入れ替えてまた実験する。matrix.cを書き換えるたびに上の2行を実行し直す必要がある。<br>


＜結果＞<br>
N = 1024で調べた。＊時間は測るたびに1~2秒変わる。<br>
i-k-j: 4.214747 sec<br>
k-i-j: 4.359899 sec<br>
j-i-k: 29.514298 sec<br>
i-j-k: 29.950374 sec<br>
j-k-i: 35.115300 sec<br>
k-j-i: 36.164341 sec<br>
予想は正しいと言える。<br>


## 宿題２<br>
C言語で行列積を書くと、i-k-jループのほうがi-j-kループよりもずっと速かった。でも、実はPythonで書くと、ループ順序を入れ替えても速度差はほとんどない。その理由を考えてください。<br>


まず、pythonとC言語でどのくらい計算にかかる時間が違うのかを調べてみた。
```
gcc matrix.c -o matrix
./matrix 256
```
```
0.114014 sec
```
```
python matrix.py 256
```
```
28.298978 sec
```
N=256では、なんと200倍以上pythonの方が遅いことが分かった。<br>
これを踏まえて、pythonで速度差が変わらない理由はpythonがインタプリタ言語であるために処理が遅く、（メモリにデータを取りに行く時間）<<（字句解析、構文解析などにかかる時間）となるためにループの順番を入れ替えることによるスピード向上が目に現れないのではないかと考えた。<br>
Nが小さくなればループの順序による計測時間の差が現れるのではないかと思い、N=10で実験してみた。が、計算時間はループの順序に依存しなかった。そこで別の理由を考える。<br>

ループの順序を変えると計算時間が少なくなる理由はキャッシュヒット率が上がるからであった。キャッシュヒット率を上げるためには<br>
1. アクセスするメモリ領域を小さくする<br>
2. 連続的にメモリにアクセスする<br>

をすれば良い。ここで、1つ目に注目した。プログラムをコンパイルすると最適化をするために機械語が生成されるが、この文余分なメモリを使うことになる。逆に、機械語を生成しないpythonは必要最低限のメモリしか使わない。これによってキャッシュヒット率が上がると考えられる。以上より、使用するメモリが少なく、連続でない領域もキャッシュ/レジスタ上に存在する確率が高まるためにpythonでの計算時間はループの順序に依存しないのではないかと思われる。<br>

正しい答えはこちら↓<br>
＜理由その１＞<br>
Pythonのリストは、リスト自体は配列で実装されていて連続メモリアドレスに入っているのですが、数値は別のところ（＝いろんな数値があればあちこちの不連続なメモリアドレス）に入っているんです。ループ順序を入れ替えたところで、数値へのアクセスが不連続なことに変わりはないので、性能に影響が出なかったわけです。<br>

＜理由その２＞<br>
Pythonがインタプリタで型のない言語だからです。C言語で、<br>
c[i][j] += a[i][k] * b[k][j]<br>
とやったとき起きることは、最適化された機械語を実行するだけで、所定のメモリアドレスからデータを取ってきて掛け算・足し算をする、それだけです。なのでメモリアクセスの速度が全体性能にもろに影響してくるのです。ところがPythonで、<br>
c[i, j] += a[i, k] * b[k, j]<br>
とやったときは「その他いろいろなこと」が起きます。たとえば、<br>
* iの型をチェックして、不正な型だったら例外を投げる。Pythonには型がないので毎回アクセスされるたびに型をチェックする必要がある。j、k、a、b、cもチェックしないといけません。<br>
* iの型が整数型で、iがリストのサイズより大きかったら例外を投げる。<br>
* iの型が整数型で、かつ負の数だったとき、リストの後ろから数えた位置に読み替える。（Pythonでは、list[-1]でリストの最後にアクセスできます。）<br>

などといったいろいろなチェックが毎回のアクセスで行われます。よって、Pythonが遅いのは当然で、これだけいろんなメモリアドレスを触ってチェックをやっていれば、配列そのものが連続アクセスになっているかどうかは全体性能に影響してこないのです。<br>


## 宿題３＠ラスボス<br>
帰ってきたTSP!Week5にChallenge7が加わった。これまでの授業を踏まえてWeek5より高得点を目指せ！<br>

＜方法＞<br>
貪欲法のひとくくりを大きくして考えてみた。現在の都市から近い15個の都市について貪欲法で5つ先までの経路を求めて、その経路が一番短いものを採用した。この際、threadを用いて並列化して計算するようにした。<br>
Challenge1~4までは全てのスタート地点、Challenge5,6についてはランダムに選んだ10通りのスタート地点から始めた経路をそれぞれ計算し、最小のものを選んだ。これもthreadで並列化して計算した。Challenge7については1つのスタート地点からのみ調べた（thread化しても時間＆PCに負担がかかるため）。<br>
コードは[MiyabiTane/google-step-tspのweek7_homeworkブランチ](https://github.com/MiyabiTane/google-step-tsp/tree/week7_homework)

結果<br>
```
Challenge 0
my_ans/thread_greedy/output:    3291.62
my_ans/remove_cross/output:    3418.10
sample/greedy   :    3418.10
sample/sa       :    3291.62

Challenge 1
my_ans/thread_greedy/output:    3832.29
my_ans/remove_cross/output:    3832.29
sample/greedy   :    3832.29
sample/sa       :    3778.72

Challenge 2
my_ans/thread_greedy/output:    4494.42
my_ans/remove_cross/output:    4974.50
sample/greedy   :    5449.44
sample/sa       :    4494.42

Challenge 3
my_ans/thread_greedy/output:    8205.30
my_ans/remove_cross/output:   10155.75
sample/greedy   :   10519.16
sample/sa       :    8150.91

Challenge 4
my_ans/thread_greedy/output:   10683.32
my_ans/remove_cross/output:   12128.92
sample/greedy   :   12684.06
sample/sa       :   10675.29

Challenge 5
my_ans/thread_greedy/output:   21671.94
my_ans/remove_cross/output:   23499.91
sample/greedy   :   25331.84
sample/sa       :   21119.55

Challenge 6
my_ans/thread_greedy/output:   43391.80
my_ans/remove_cross/output:   46737.15
sample/greedy   :   49892.05
sample/sa       :   44393.89

Challenge 7
my_ans/thread_greedy/output:   87940.69
sample/greedy   :   95983.29
sample/random   : 5419460.57
```

この解にはランダム性があるため、ベストスコアを別で載せておく。<br>
Challenge6 ▷ thread_greedy : 43296.5249493788<br>
Challenge7 ▷ thread_greedy : 87018.3416330413<br>